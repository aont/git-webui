<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>git apply web ui</title>
    <link rel="stylesheet" href="style.css">

</head>
<body class="theme-root page-body">
<main class="page-main">
    <div class="page-header">
        <h1 class="page-title">git apply --3way Web UI</h1>
        <button type="button" class="button secondary" id="theme_toggle" aria-live="polite">Theme: Auto</button>
    </div>
    <p>Apply a patch to a GitHub repository, commit it, and push the result.</p>
    <form method="post" action="/" id="apply_form" class="design-form" novalidate>
        <div>
            <div class="field-header">
                <label for="repository_url">Repository URL (SSH recommended)</label>
                <a class="button secondary hidden" id="open_repository" href="" target="_blank" rel="noopener">Open on GitHub</a>
            </div>
            <div class="field-group">
                <input type="text" id="repository_url" name="repository_url" required list="repository_history">
            </div>
            <datalist id="repository_history"></datalist>
        </div>
        <div id="branch_group">
            <label for="branch">Branch (optional: use the current branch)</label>
            <input type="text" id="branch" name="branch" list="branch_history">
            <datalist id="branch_history"></datalist>
        </div>
        <div>
            <label>Mode</label>
            <div class="toggle-group" role="radiogroup" aria-label="Mode">
                <label>
                    <input type="radio" name="branch_mode" value="default" checked>
                    Default behavior (checkout when a branch is specified)
                </label>
                <label>
                    <input type="radio" name="branch_mode" value="from_commit">
                    Create a new branch from the specified commit
                </label>
                <label>
                    <input type="radio" name="branch_mode" value="orphan">
                    Create an orphan branch
                </label>
                <label>
                    <input type="radio" name="branch_mode" value="revert_to_commit">
                    Reset an existing branch to the specified commit and force-push
                </label>
            </div>
            <p class="subtle">A new branch name is required for commit-based or orphan modes. Revert mode requires an existing branch and commit ID.</p>
        </div>
        <div id="new_branch_group" class="hidden">
            <label for="new_branch">New Branch Name</label>
            <input type="text" id="new_branch" name="new_branch">
        </div>
        <div id="commit_id_group" class="hidden">
            <label for="base_commit" id="base_commit_label">Base Commit ID (e.g., a1b2c3d)</label>
            <input type="text" id="base_commit" name="base_commit">
        </div>
        <div id="git_user_group">
            <label for="git_user">Git User (Name &amp; Email)</label>
            <select id="git_user" name="git_user">
                <option value="">Loading git users...</option>
            </select>
        </div>
        <div id="commit_message_group">
            <div class="field-header">
                <label for="commit_message">Commit Message</label>
                <div class="field-header-actions">
                    <button type="button" class="button secondary" id="paste_commit_message" data-paste-target="commit_message">
                        Paste from clipboard
                    </button>
                    <button type="button" class="button secondary" id="copy_patch">
                        Prompt for generating a commit message
                    </button>
                    <a class="button secondary" id="open_chatgpt" href="#" target="_blank" rel="noopener noreferrer">
                        Generate with ChatGPT
                    </a>
                </div>
            </div>
            <textarea id="commit_message" name="commit_message" placeholder="e.g., Apply patch from Web UI"></textarea>
        </div>
        <div id="allow_empty_group">
            <label>
                <input type="checkbox" id="allow_empty_commit" name="allow_empty_commit" value="true">
                Empty Commit
            </label>
        </div>
        <div id="ssh_key_group">
            <label for="ssh_key_path">SSH Private Key</label>
            <select id="ssh_key_path" name="ssh_key_path">
                <option value="">Loading SSH keys...</option>
            </select>
        </div>
        <div id="patch_group">
            <div class="field-header">
                <label for="patch">Patch (applied with git apply --3way -v)</label>
                <button type="button" class="button secondary" id="paste_patch" data-paste-target="patch">
                    Paste from clipboard
                </button>
            </div>
            <textarea id="patch" name="patch" placeholder="diff --git a/..."></textarea>
        </div>
        <div id="pr_message_group">
            <label for="pr_message">PR Message</label>
            <textarea id="pr_message" name="pr_message" placeholder="e.g., Release notes or PR summary"></textarea>
        </div>
        <div>
            <div class="field-header">
                <label for="backend_url">Backend URL</label>
                <div class="field-header-actions">
                    <span id="backend_status" class="status-pill">disconnected</span>
                    <button type="button" class="button secondary" id="backend_apply">Connect</button>
                    <button type="button" class="button secondary" id="backend_disconnect">Disconnect</button>
                </div>
            </div>
            <div class="field-group">
                <input type="text" id="backend_url" name="backend_url" placeholder="http://localhost:8080/ws">
            </div>
            <p class="subtle">Set the backend WebSocket endpoint as an absolute URL (including the /ws path). Examples: http://localhost:8080/ws, ws://localhost:8080/ws, https://localhost:1443/ws, wss://localhost:1443/ws. This value is saved in your browser.</p>
        </div>
        <button type="button" class="button" id="submit_button">Apply Patch &amp; Push</button>
    </form>
    <section id="log_section" class="logs hidden">
        <div class="field-header">
            <h2 id="log_status">Logs</h2>
            <button type="button" class="button secondary" id="clear_logs">Clear logs</button>
        </div>
        <pre id="log_output"></pre>
    </section>
</main>
<div id="result_modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="result_title">
    <div class="modal-content" role="document">
        <h2 id="result_title">Request Complete</h2>
        <p id="result_message">Your request has finished.</p>
        <div class="modal-actions">
            <button type="button" class="button" id="result_close">Close</button>
        </div>
    </div>
</div>
<script src="theme-toggle.js"></script>
<script>
    const form = document.getElementById("apply_form");
    const submitButton = document.getElementById("submit_button");
    const allowEmptyCommit = document.getElementById("allow_empty_commit");
    const patchField = document.getElementById("patch");
    const branchModeInputs = document.querySelectorAll("input[name='branch_mode']");
    const commitIdGroup = document.getElementById("commit_id_group");
    const commitIdField = document.getElementById("base_commit");
    const commitIdLabel = document.getElementById("base_commit_label");
    const branchGroup = document.getElementById("branch_group");
    const repositoryField = document.getElementById("repository_url");
    const branchField = document.getElementById("branch");
    const newBranchGroup = document.getElementById("new_branch_group");
    const newBranchField = document.getElementById("new_branch");
    const gitUserGroup = document.getElementById("git_user_group");
    const commitMessageGroup = document.getElementById("commit_message_group");
    const allowEmptyGroup = document.getElementById("allow_empty_group");
    const patchGroup = document.getElementById("patch_group");
    const prMessageGroup = document.getElementById("pr_message_group");
    const gitUserField = document.getElementById("git_user");
    const commitMessageField = document.getElementById("commit_message");
    const prMessageField = document.getElementById("pr_message");
    const sshKeyField = document.getElementById("ssh_key_path");
    const openRepositoryButton = document.getElementById("open_repository");
    const pasteCommitMessageButton = document.getElementById("paste_commit_message");
    const pastePatchButton = document.getElementById("paste_patch");
    const openChatGPTButton = document.getElementById("open_chatgpt");
    const isClipboardPasteAvailable =
        typeof navigator !== "undefined" &&
        navigator.clipboard &&
        typeof navigator.clipboard.readText === "function";
    if (!isClipboardPasteAvailable) {
        [pasteCommitMessageButton, pastePatchButton].forEach((button) => {
            if (button) {
                button.classList.add("hidden");
            }
        });
    }
    const copyPatchButton = document.getElementById("copy_patch");
    const copyPatchBaseLabel = copyPatchButton ? copyPatchButton.textContent.trim() : "";
    const setCopyPatchButtonCopiedState = (copied) => {
        if (!copyPatchButton) {
            return;
        }
        copyPatchButton.dataset.copied = copied ? "true" : "false";
        copyPatchButton.textContent = copied ? copyPatchBaseLabel + " ✅" : copyPatchBaseLabel;
    };
    const toggleCommitMessageHelpers = () => {
        const shouldHide = allowEmptyCommit.checked;
        if (copyPatchButton) {
            copyPatchButton.classList.toggle("hidden", shouldHide);
        }
        if (openChatGPTButton) {
            openChatGPTButton.classList.toggle("hidden", shouldHide);
        }
    };
    const clearCopyPatchIndicatorIfPatchChanged = () => {
        if (!copyPatchButton || copyPatchButton.dataset.copied !== "true") {
            return;
        }
        if (patchField.value !== lastCopiedPatchValue) {
            setCopyPatchButtonCopiedState(false);
        }
    };
    setCopyPatchButtonCopiedState(false);
    const logSection = document.getElementById("log_section");
    const logOutput = document.getElementById("log_output");
    const logStatus = document.getElementById("log_status");
    const clearLogsButton = document.getElementById("clear_logs");
    const repositoryHistoryList = document.getElementById("repository_history");
    const branchHistoryList = document.getElementById("branch_history");
    const backendUrlField = document.getElementById("backend_url");
    const backendApplyButton = document.getElementById("backend_apply");
    const backendDisconnectButton = document.getElementById("backend_disconnect");
    const backendStatus = document.getElementById("backend_status");
    const resultModal = document.getElementById("result_modal");
    const resultTitle = document.getElementById("result_title");
    const resultMessage = document.getElementById("result_message");
    const resultCloseButton = document.getElementById("result_close");

    const REPOSITORY_STORAGE_KEY = "git-webui.repositories";
    const BRANCH_STORAGE_KEY = "git-webui.branches";
    const BACKEND_STORAGE_KEY = "git-webui.backendUrl";
    const DRAFT_STORAGE_KEY = "git-webui.draft";
    const MAX_STORED_VALUES = 10;
    let logSocket = null;
    let gitUserConfig = [];
    let draftSaveTimeout = null;
    let defaultGitUserIndex = null;
    let lastCopiedPatchValue = "";
    let manualDisconnect = false;

    const parseGitHubRepository = (value) => {
        if (!value || typeof value !== "string") {
            return null;
        }
        const trimmed = value.trim();
        const match = trimmed.match(/^git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/i);
        if (!match) {
            return null;
        }
        return { owner: match[1], repo: match[2] };
    };

    const encodeBranchForUrl = (branch) => encodeURIComponent(branch).replace(/%2F/g, "/");

    const updateRepositoryLinkButton = () => {
        if (!openRepositoryButton) {
            return;
        }
        const repoInfo = parseGitHubRepository(repositoryField.value);
        if (!repoInfo) {
            openRepositoryButton.classList.add("hidden");
            openRepositoryButton.removeAttribute("href");
            return;
        }
        const branchValue = branchField.value.trim();
        const branchSuffix = branchValue ? "/tree/" + encodeBranchForUrl(branchValue) : "";
        const url = "https://github.com/" + repoInfo.owner + "/" + repoInfo.repo + branchSuffix;
        openRepositoryButton.href = url;
        openRepositoryButton.classList.remove("hidden");
    };

    const updateBackendStatus = (state, message) => {
        if (!backendStatus) {
            return;
        }
        backendStatus.textContent = message;
        backendStatus.classList.remove("connected", "error");
        if (state === "connected") {
            backendStatus.classList.add("connected");
        }
        if (state === "error") {
            backendStatus.classList.add("error");
        }
    };

    const appendLogLine = (line) => {
        if (!logSection || !logOutput || !logStatus) {
            return;
        }
        logSection.classList.remove("hidden");
        logStatus.textContent = "Logs";
        logOutput.textContent += (logOutput.textContent ? "\n" : "") + line;
        logOutput.scrollTop = logOutput.scrollHeight;
    };

    const updateLogStatus = (success) => {
        if (!logSection || !logStatus) {
            return;
        }
        logSection.classList.remove("success", "failure", "neutral");
        if (success === true) {
            logSection.classList.add("success");
            logStatus.textContent = "Success";
        } else if (success === false) {
            logSection.classList.add("failure");
            logStatus.textContent = "Failure";
        } else {
            logSection.classList.add("neutral");
            logStatus.textContent = "Logs";
        }
    };

    const showResultModal = (success, message) => {
        if (!resultModal || !resultTitle || !resultMessage) {
            return;
        }
        const modalContent = resultModal.querySelector(".modal-content");
        if (modalContent) {
            modalContent.classList.remove("success", "failure");
            modalContent.classList.add(success ? "success" : "failure");
        }
        resultTitle.textContent = success ? "Request Succeeded" : "Request Failed";
        resultMessage.textContent = message;
        resultModal.classList.remove("hidden");
        if (resultCloseButton) {
            resultCloseButton.focus();
        }
    };

    const hideResultModal = () => {
        if (!resultModal) {
            return;
        }
        resultModal.classList.add("hidden");
    };

    const clearProcessingFields = () => {
        if (commitMessageField) {
            commitMessageField.value = "";
        }
        if (prMessageField) {
            prMessageField.value = "";
        }
        if (patchField) {
            patchField.value = "";
        }
        if (newBranchField) {
            newBranchField.value = "";
        }
        scheduleDraftSave();
    };

    const normalizeBackendUrl = (value) => {
        const trimmed = value.trim();
        return trimmed.replace(/\/+$/, "");
    };

    const getQueryParams = () => {
        const searchParams = new URLSearchParams(window.location.search);
        if ([...searchParams.keys()].length > 0) {
            return { params: searchParams, source: "search" };
        }
        if (window.location.hash.startsWith("#?")) {
            return { params: new URLSearchParams(window.location.hash.slice(2)), source: "hash" };
        }
        return { params: searchParams, source: "none" };
    };
    const { params: queryParams, source: querySource } = getQueryParams();
    const hasQueryParams = [...queryParams.keys()].length > 0;

    const getBackendUrl = () => {
        const stored = window.localStorage.getItem(BACKEND_STORAGE_KEY);
        const fallback = window.location.origin;
        return normalizeBackendUrl(stored || fallback);
    };

    const setBackendUrl = (value) => {
        const normalized = normalizeBackendUrl(value || window.location.origin);
        window.localStorage.setItem(BACKEND_STORAGE_KEY, normalized);
        if (backendUrlField) {
            backendUrlField.value = normalized;
        }
        return normalized;
    };

    const buildBackendUrl = (path) => {
        const base = getBackendUrl();
        return new URL(path, base).toString();
    };

    const connectWebSocket = () => {
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
            return;
        }
        const wsUrl = new URL(getBackendUrl());
        wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
        logSocket = new WebSocket(wsUrl.toString());
        logSocket.addEventListener("open", () => {
            updateBackendStatus("connected", "connected");
        });
        logSocket.addEventListener("close", () => {
            if (manualDisconnect) {
                updateBackendStatus("", "disconnected");
                manualDisconnect = false;
                return;
            }
            updateBackendStatus("error", "disconnected");
        });
        logSocket.addEventListener("error", () => {
            updateBackendStatus("error", "error");
        });
        logSocket.addEventListener("message", (event) => {
            let payload;
            try {
                payload = JSON.parse(event.data);
            } catch (error) {
                appendLogLine(event.data);
                return;
            }
            if (payload.type === "log") {
                appendLogLine(payload.line);
            }
            if (payload.type === "complete") {
                updateLogStatus(payload.success);
                if (payload.success) {
                    clearProcessingFields();
                }
                showResultModal(
                    payload.success,
                    payload.success
                        ? "The request finished successfully."
                        : "The request finished, but there were errors. Review the logs for details.",
                );
            }
            if (payload.type === "error") {
                appendLogLine(payload.message);
                updateLogStatus(false);
                showResultModal(false, payload.message || "The request failed. Review the logs for details.");
            }
        });
    };

    const readStoredValues = (key) => {
        try {
            const raw = window.localStorage.getItem(key);
            if (!raw) {
                return [];
            }
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) {
                return [];
            }
            return parsed.filter((value) => typeof value === "string");
        } catch (error) {
            console.warn("Failed to read stored values", error);
            return [];
        }
    };

    const writeStoredValues = (key, values) => {
        window.localStorage.setItem(key, JSON.stringify(values));
    };

    const addStoredValue = (key, value) => {
        const trimmed = value.trim();
        if (!trimmed) {
            return readStoredValues(key);
        }
        const existing = readStoredValues(key);
        const nextValues = [trimmed, ...existing.filter((item) => item !== trimmed)].slice(0, MAX_STORED_VALUES);
        writeStoredValues(key, nextValues);
        return nextValues;
    };

    const renderStoredOptions = (values, datalist) => {
        if (datalist) {
            datalist.innerHTML = values.map((value) => "<option value=\"" + value + "\"></option>").join("");
        }
    };

    const refreshStoredSelections = () => {
        renderStoredOptions(
            readStoredValues(REPOSITORY_STORAGE_KEY),
            repositoryHistoryList,
        );
        renderStoredOptions(
            readStoredValues(BRANCH_STORAGE_KEY),
            branchHistoryList,
        );
    };

    const persistStoredSelections = () => {
        const repoValues = addStoredValue(REPOSITORY_STORAGE_KEY, repositoryField.value);
        const branchValues = addStoredValue(BRANCH_STORAGE_KEY, branchField.value);
        renderStoredOptions(repoValues, repositoryHistoryList);
        renderStoredOptions(branchValues, branchHistoryList);
    };

    const readDraft = () => {
        try {
            const raw = window.localStorage.getItem(DRAFT_STORAGE_KEY);
            if (!raw) {
                return {};
            }
            const parsed = JSON.parse(raw);
            return parsed && typeof parsed === "object" ? parsed : {};
        } catch (error) {
            console.warn("Failed to read draft input", error);
            return {};
        }
    };

    const writeDraft = (draft) => {
        window.localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
    };

    const getSelectedBranchMode = () => {
        const selected = document.querySelector("input[name='branch_mode']:checked");
        return selected ? selected.value : "default";
    };

    const collectDraft = () => ({
        backend_url: backendUrlField ? backendUrlField.value : "",
        repository_url: repositoryField.value,
        branch: branchField.value,
        branch_mode: getSelectedBranchMode(),
        new_branch: newBranchField.value,
        base_commit: commitIdField.value,
        git_user: gitUserField.value,
        commit_message: commitMessageField.value,
        pr_message: prMessageField.value,
        allow_empty_commit: allowEmptyCommit.checked,
        ssh_key_path: sshKeyField.value,
        patch: patchField.value,
    });

    const defaultFormState = collectDraft();

    const applyDraftValue = (field, value) => {
        if (!field || value === undefined || value === null) {
            return;
        }
        field.value = value;
    };

    const applyDraft = (draft) => {
        if (!draft || typeof draft !== "object") {
            return;
        }
        if (backendUrlField && typeof draft.backend_url === "string") {
            backendUrlField.value = draft.backend_url;
        }
        applyDraftValue(repositoryField, draft.repository_url);
        applyDraftValue(branchField, draft.branch);
        if (typeof draft.branch_mode === "string") {
            branchModeInputs.forEach((input) => {
                input.checked = input.value === draft.branch_mode;
            });
        }
        applyDraftValue(newBranchField, draft.new_branch);
        applyDraftValue(commitIdField, draft.base_commit);
        applyDraftValue(gitUserField, draft.git_user);
        applyDraftValue(commitMessageField, draft.commit_message);
        applyDraftValue(prMessageField, draft.pr_message);
        if (typeof draft.allow_empty_commit === "boolean") {
            allowEmptyCommit.checked = draft.allow_empty_commit;
        }
        applyDraftValue(sshKeyField, draft.ssh_key_path);
        applyDraftValue(patchField, draft.patch);
        clearCopyPatchIndicatorIfPatchChanged();
        updateRepositoryLinkButton();
        updateChatGPTLink();
    };

    const scheduleDraftSave = () => {
        if (draftSaveTimeout) {
            window.clearTimeout(draftSaveTimeout);
        }
        draftSaveTimeout = window.setTimeout(() => {
            writeDraft(collectDraft());
        }, 200);
    };

    const ensureWebSocketReady = () => new Promise((resolve) => {
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
            resolve();
            return;
        }
        connectWebSocket();
        logSocket.addEventListener("open", () => resolve(), { once: true });
    });

    const sendFormOverWebSocket = async () => {
        await ensureWebSocketReady();
        const payload = Object.fromEntries(new FormData(form).entries());
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
            updateLogStatus(null);
            if (logOutput) {
                logOutput.textContent = "";
            }
            logSocket.send(JSON.stringify({ type: "submit", payload }));
        } else {
            appendLogLine("[client] WebSocket connection not ready.");
            updateLogStatus(false);
        }
    };

    const togglePatchRequired = () => {
        const hidePrMessage = allowEmptyCommit.checked;
        patchField.required = !allowEmptyCommit.checked;
        patchGroup.classList.toggle("hidden", allowEmptyCommit.checked);
        if (allowEmptyCommit.checked) {
            patchField.removeAttribute("name");
            patchField.setAttribute("disabled", "");
        } else {
            patchField.setAttribute("name", "patch");
            patchField.removeAttribute("disabled", "");
        }
        if (prMessageGroup) {
            prMessageGroup.classList.toggle("hidden", hidePrMessage);
        }
        if (prMessageField) {
            if (hidePrMessage) {
                prMessageField.setAttribute("disabled", "");
            } else {
                prMessageField.removeAttribute("disabled");
            }
        }
        if (pastePatchButton) {
            pastePatchButton.disabled = patchField.hasAttribute("disabled");
        }
        if (copyPatchButton) {
            copyPatchButton.disabled = patchField.hasAttribute("disabled");
        }
        if (patchField.hasAttribute("disabled")) {
            setCopyPatchButtonCopiedState(false);
        } else {
            clearCopyPatchIndicatorIfPatchChanged();
        }
        toggleCommitMessageHelpers();
    };

    const toggleCommitField = () => {
        const selectedMode = document.querySelector("input[name='branch_mode']:checked").value;
        const needsCommit = selectedMode === "from_commit" || selectedMode === "revert_to_commit";
        const needsNewBranch = selectedMode === "from_commit" || selectedMode === "orphan";
        const needsExistingBranch = selectedMode === "revert_to_commit";
        commitIdGroup.classList.toggle("hidden", !needsCommit);
        if (needsCommit) {
            commitIdField.removeAttribute("disabled");
            commitIdField.setAttribute("required", "");
            if (commitIdLabel) {
                commitIdLabel.textContent = selectedMode === "revert_to_commit"
                    ? "Commit ID to Reset Branch To (e.g., a1b2c3d)"
                    : "Base Commit ID (e.g., a1b2c3d)";
            }
        } else {
            commitIdField.setAttribute("disabled", "");
            commitIdField.removeAttribute("required");
        }
        newBranchGroup.classList.toggle("hidden", !needsNewBranch);
        if (needsNewBranch) {
            newBranchField.removeAttribute("disabled");
            newBranchField.setAttribute("required", "");
            branchField.setAttribute("disabled", "");
        } else {
            newBranchField.setAttribute("disabled", "");
            newBranchField.removeAttribute("required");
            if (!needsExistingBranch) {
                branchField.removeAttribute("disabled");
            }
        }
        const hideDetails = selectedMode === "from_commit" || selectedMode === "revert_to_commit";
        branchGroup.classList.toggle("hidden", !(selectedMode === "default" || needsExistingBranch));
        if (selectedMode === "default" || needsExistingBranch) {
            branchField.removeAttribute("disabled");
            if (needsExistingBranch) {
                branchField.setAttribute("required", "");
            } else {
                branchField.removeAttribute("required");
            }
        } else {
            branchField.setAttribute("disabled", "");
            branchField.removeAttribute("required");
        }
        gitUserGroup.classList.toggle("hidden", hideDetails);
        commitMessageGroup.classList.toggle("hidden", hideDetails);
        prMessageGroup.classList.toggle("hidden", hideDetails);
        allowEmptyGroup.classList.toggle("hidden", hideDetails);
        patchGroup.classList.toggle("hidden", hideDetails || allowEmptyCommit.checked);
        if (hideDetails) {
            gitUserField.setAttribute("disabled", "");
            commitMessageField.setAttribute("disabled", "");
            prMessageField.setAttribute("disabled", "");
            allowEmptyCommit.setAttribute("disabled", "");
            patchField.setAttribute("disabled", "");
            if (pastePatchButton) {
                pastePatchButton.disabled = true;
            }
            if (copyPatchButton) {
                copyPatchButton.disabled = true;
            }
            setCopyPatchButtonCopiedState(false);
        } else {
            gitUserField.removeAttribute("disabled");
            commitMessageField.removeAttribute("disabled");
            prMessageField.removeAttribute("disabled");
            allowEmptyCommit.removeAttribute("disabled");
            togglePatchRequired();
        }
        if (pasteCommitMessageButton) {
            pasteCommitMessageButton.disabled = commitMessageField.hasAttribute("disabled");
        }
    };

    const resetSelect = (select, message) => {
        if (!select) {
            return;
        }
        select.innerHTML = "";
        const option = document.createElement("option");
        option.value = "";
        option.textContent = message;
        select.appendChild(option);
    };

    const normalizeRepository = (value) => {
        if (!value) {
            return "";
        }
        const trimmed = value.trim();
        if (!trimmed) {
            return "";
        }
        let normalized = trimmed;
        if (trimmed.includes("://")) {
            try {
                const url = new URL(trimmed);
                normalized = url.hostname + url.pathname;
            } catch (error) {
                normalized = trimmed;
            }
        } else {
            const scpMatch = trimmed.match(/^(?:[^@]+@)?([^:]+):(.+)$/);
            if (scpMatch) {
                normalized = scpMatch[1] + "/" + scpMatch[2];
            }
        }
        normalized = normalized.replace(/^\/+/, "").replace(/\/+$/, "");
        normalized = normalized.replace(/\.git$/i, "");
        return normalized.toLowerCase();
    };

    const findDefaultGitUserIndexForRepo = (repositoryUrl) => {
        if (!repositoryUrl) {
            return null;
        }
        const normalizedRepo = normalizeRepository(repositoryUrl);
        if (!normalizedRepo) {
            return null;
        }
        for (let idx = 0; idx < gitUserConfig.length; idx += 1) {
            const entry = gitUserConfig[idx];
            const defaults = Array.isArray(entry.default_repositories) ? entry.default_repositories : [];
            for (const repoValue of defaults) {
                if (normalizeRepository(repoValue) === normalizedRepo) {
                    return idx;
                }
            }
        }
        return null;
    };

    const applyDefaultGitUserForRepository = () => {
        if (!gitUserField || gitUserField.hasAttribute("disabled")) {
            return;
        }
        const repoValue = repositoryField.value;
        const matchIndex = findDefaultGitUserIndexForRepo(repoValue);
        if (typeof matchIndex === "number") {
            gitUserField.value = String(matchIndex);
        } else if (repoValue && typeof defaultGitUserIndex === "number") {
            gitUserField.value = String(defaultGitUserIndex);
        }
    };

    const populateConfig = (payload) => {
        if (!payload) {
            return;
        }
        const sshKeys = Array.isArray(payload.ssh_keys) ? payload.ssh_keys : [];
        const gitUsers = Array.isArray(payload.git_users) ? payload.git_users : [];
        gitUserConfig = gitUsers;
        sshKeyField.innerHTML = "";
        if (sshKeys.length === 0) {
            resetSelect(sshKeyField, "(No SSH keys configured)");
        } else {
            sshKeys.forEach((entry, idx) => {
                const option = document.createElement("option");
                option.value = String(idx);
                option.textContent = entry.label || "Unknown Key";
                sshKeyField.appendChild(option);
            });
        }
        gitUserField.innerHTML = "";
        if (gitUsers.length === 0) {
            resetSelect(gitUserField, "(No Git users configured)");
        } else {
            gitUsers.forEach((entry, idx) => {
                const option = document.createElement("option");
                option.value = String(idx);
                option.textContent = entry.label || "Unknown User";
                gitUserField.appendChild(option);
            });
        }
        const defaultSshIndex = payload.default_ssh_key_index;
        if (typeof defaultSshIndex === "number" && sshKeys[defaultSshIndex]) {
            sshKeyField.value = String(defaultSshIndex);
        }
        defaultGitUserIndex = payload.default_git_user_index;
        if (typeof defaultGitUserIndex === "number" && gitUsers[defaultGitUserIndex]) {
            gitUserField.value = String(defaultGitUserIndex);
        } else {
            defaultGitUserIndex = null;
        }
        applyDefaultGitUserForRepository();
    };

    const fetchConfig = async () => {
        try {
            const response = await fetch(buildBackendUrl("/api/config"));
            if (!response.ok) {
                throw new Error("Config request failed: " + response.status);
            }
            const payload = await response.json();
            populateConfig(payload);
            updateBackendStatus("connected", "connected");
        } catch (error) {
            console.error("Failed to load backend config", error);
            resetSelect(sshKeyField, "(Unable to load SSH keys)");
            resetSelect(gitUserField, "(Unable to load Git users)");
            updateBackendStatus("error", "config error");
        }
    };

    const applyBackend = () => {
        const backendUrl = setBackendUrl(backendUrlField.value);
        manualDisconnect = false;
        updateBackendStatus("", "connecting");
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
            manualDisconnect = true;
            logSocket.close();
        }
        connectWebSocket();
        fetchConfig();
        appendLogLine("[client] Using backend " + backendUrl);
    };

    const disconnectBackend = () => {
        manualDisconnect = true;
        if (logSocket && logSocket.readyState !== WebSocket.CLOSED) {
            logSocket.close();
        } else {
            manualDisconnect = false;
        }
        logSocket = null;
        updateBackendStatus("", "disconnected");
        appendLogLine("[client] Disconnected from backend");
    };

    allowEmptyCommit.addEventListener("change", togglePatchRequired);
    branchModeInputs.forEach((input) => {
        input.addEventListener("change", toggleCommitField);
    });
    if (repositoryField) {
        repositoryField.addEventListener("input", applyDefaultGitUserForRepository);
        repositoryField.addEventListener("change", applyDefaultGitUserForRepository);
        repositoryField.addEventListener("input", updateRepositoryLinkButton);
        repositoryField.addEventListener("change", updateRepositoryLinkButton);
    }
    if (branchField) {
        branchField.addEventListener("input", updateRepositoryLinkButton);
        branchField.addEventListener("change", updateRepositoryLinkButton);
    }
    if (openRepositoryButton) {
        openRepositoryButton.addEventListener("click", (event) => {
            if (!openRepositoryButton.getAttribute("href")) {
                event.preventDefault();
            }
        });
    }

    const clearLogs = () => {
        if (logOutput) {
            logOutput.textContent = "";
        }
        updateLogStatus(null);
    };

    const handleSubmit = (event) => {
        event.preventDefault();
        event.stopPropagation();
        clearLogs();
        persistStoredSelections();
        sendFormOverWebSocket();
    };

    if (submitButton) {
        submitButton.addEventListener("click", handleSubmit);
    }
    if (clearLogsButton) {
        clearLogsButton.addEventListener("click", clearLogs);
    }
    form.addEventListener("submit", handleSubmit);
    form.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && event.target.tagName !== "TEXTAREA") {
            handleSubmit(event);
        }
    });

    const pasteFromClipboard = async (targetId) => {
        const target = document.getElementById(targetId);
        if (!target) {
            return;
        }
        try {
            const clipboardText = await navigator.clipboard.readText();
            target.value = clipboardText;
            target.focus();
            scheduleDraftSave();
            if (target === patchField) {
                clearCopyPatchIndicatorIfPatchChanged();
            }
            if (target === patchField || target === prMessageField) {
                updateChatGPTLink();
            }
        } catch (error) {
            console.error("Clipboard paste failed", error);
            alert("Unable to read from the clipboard. Please paste manually.");
        }
    };

    const patchCopyPrompt = "Based on the changes described after “---- Changes ----”, propose 2–5 English Git commit message candidates.\n\nOutput requirements:\n\n* Follow the Conventional Commits format, and ensure the title line is in the form `type(scope): summary` (e.g., `refactor(config): ...`).\n* For each candidate, use the order: “one-line title” → “blank line” → “body”. The body should be a bulleted list (`-`) with about 0–5 lines.\n* Differentiate each candidate so that expressions and level of detail (short / standard / more detailed) do not overlap.\n* Output each candidate in a separate code block.\n\n```\n{title}\n\n- {body_item_1}\n...\n```\n\nEvaluation requirements:\n\n* Immediately after each candidate, always include (in English) a “Recommended adoption level” (⭐⭐⭐☆☆) and a “Reason” (English, 1–3 sentences).\n* In the reason, include perspectives on coverage of the changes, clarity, conformity to Conventional Commits, and future searchability (appropriateness of scope/type).\n\n---- Changes ----\n\n\n";
    const buildGeneratedAtComment = () => {
        return "<!-- ignore this: generated at " + new Date().toISOString() + " -->";
    };

    const buildPatchPrompt = () => {
        if (!patchField || !prMessageField) {
            return "";
        }
        return (
            patchCopyPrompt +
            "\n" +
            prMessageField.value +
            "\n\n" +
            patchField.value +
            "\n\n" +
            buildGeneratedAtComment()
        );
    };

    const copyPatchToClipboard = async () => {
        if (!patchField) {
            return;
        }
        const clipboardText = buildPatchPrompt();
        let copySucceeded = false;
        try {
            const temporaryField = document.createElement("textarea");
            temporaryField.value = clipboardText;
            temporaryField.setAttribute("readonly", "");
            temporaryField.style.position = "absolute";
            temporaryField.style.left = "-9999px";
            document.body.appendChild(temporaryField);
            temporaryField.select();
            copySucceeded = document.execCommand("copy");
            document.body.removeChild(temporaryField);
        } catch (error) {
            console.warn("document.execCommand copy failed", error);
        }
        if (!copySucceeded) {
            try {
                await navigator.clipboard.writeText(clipboardText);
                copySucceeded = true;
            } catch (error) {
                console.error("Clipboard copy failed", error);
            }
        }
        if (!copySucceeded) {
            alert("Unable to copy the patch to the clipboard. Please copy manually.");
            setCopyPatchButtonCopiedState(false);
            return;
        }
        lastCopiedPatchValue = patchField.value;
        setCopyPatchButtonCopiedState(true);
    };

    const updateChatGPTLink = () => {
        if (!openChatGPTButton) {
            return;
        }
        const prompt = buildPatchPrompt();
        const isIOS =
            /iPad|iPhone|iPod/.test(navigator.userAgent) ||
            (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const urlBase = isIOS ? "chatgpt://chatgpt.com/?model=gpt-5-2-instant&q=" : "https://chatgpt.com/#?model=gpt-5-2-instant&q=";
        const url = urlBase + encodeURIComponent(prompt);
        openChatGPTButton.href = url;
    };

    const bindPasteButton = (button) => {
        if (!button) {
            return;
        }
        const targetId = button.getAttribute("data-paste-target");
        button.addEventListener("click", () => pasteFromClipboard(targetId));
    };

    bindPasteButton(pasteCommitMessageButton);
    bindPasteButton(pastePatchButton);
    if (copyPatchButton) {
        copyPatchButton.addEventListener("click", copyPatchToClipboard);
    }
    updateChatGPTLink();
    refreshStoredSelections();

    const prefillFromQueryParams = async () => {
        if (!hasQueryParams) {
            return;
        }
        applyDraft(defaultFormState);
        if (queryParams.has("repository_url")) {
            repositoryField.value = queryParams.get("repository_url") || "";
        }
        if (queryParams.has("branch")) {
            branchField.value = queryParams.get("branch") || "";
        }
        if (queryParams.has("branch_mode")) {
            const mode = queryParams.get("branch_mode") || "";
            branchModeInputs.forEach((input) => {
                input.checked = input.value === mode;
            });
        }
        if (queryParams.has("new_branch")) {
            newBranchField.value = queryParams.get("new_branch") || "";
        }
        if (queryParams.has("base_commit")) {
            commitIdField.value = queryParams.get("base_commit") || "";
        }
        if (queryParams.has("git_user")) {
            gitUserField.value = queryParams.get("git_user") || "";
        }
        if (queryParams.has("commit_message")) {
            commitMessageField.value = queryParams.get("commit_message") || "";
        }
        if (queryParams.has("pr_message")) {
            prMessageField.value = queryParams.get("pr_message") || "";
        }
        if (queryParams.has("allow_empty_commit")) {
            const allowEmptyValue = (queryParams.get("allow_empty_commit") || "").toLowerCase();
            allowEmptyCommit.checked = ["true", "1", "yes", "on"].includes(allowEmptyValue);
        }
        if (queryParams.has("ssh_key_path")) {
            sshKeyField.value = queryParams.get("ssh_key_path") || "";
        }
        if (queryParams.has("patch")) {
            const patchParam = queryParams.get("patch") || "";
            patchField.value = patchParam;
        }
        clearCopyPatchIndicatorIfPatchChanged();
        applyDefaultGitUserForRepository();
        updateRepositoryLinkButton();
        const cleanHash = querySource === "hash" ? "" : window.location.hash;
        const cleanUrl = window.location.pathname + cleanHash;
        window.history.pushState({}, "", cleanUrl);
    };

    if (backendApplyButton) {
        backendApplyButton.addEventListener("click", applyBackend);
    }
    if (backendDisconnectButton) {
        backendDisconnectButton.addEventListener("click", disconnectBackend);
    }

    if (resultCloseButton) {
        resultCloseButton.addEventListener("click", hideResultModal);
    }
    if (resultModal) {
        resultModal.addEventListener("click", (event) => {
            if (event.target === resultModal) {
                hideResultModal();
            }
        });
    }

    const initializeForm = async () => {
        const savedDraft = readDraft();
        if (!hasQueryParams) {
            applyDraft(savedDraft);
        }
        await prefillFromQueryParams();
        if (backendUrlField && !backendUrlField.value.trim()) {
            const storedBackend = window.localStorage.getItem(BACKEND_STORAGE_KEY);
            const draftBackend = typeof savedDraft.backend_url === "string" ? savedDraft.backend_url : "";
            backendUrlField.value = normalizeBackendUrl(storedBackend || draftBackend || window.location.origin);
        }
        updateChatGPTLink();
        togglePatchRequired();
        toggleCommitField();
        scheduleDraftSave();
    };
    initializeForm();

    form.addEventListener("input", scheduleDraftSave);
    form.addEventListener("change", scheduleDraftSave);
    if (patchField) {
        patchField.addEventListener("input", clearCopyPatchIndicatorIfPatchChanged);
        patchField.addEventListener("input", updateChatGPTLink);
    }
    if (prMessageField) {
        prMessageField.addEventListener("input", updateChatGPTLink);
    }

    const startingBackend = backendUrlField && backendUrlField.value ? backendUrlField.value : getBackendUrl();
    const initialBackend = setBackendUrl(startingBackend);
    updateBackendStatus("", "connecting");
    if (backendUrlField) {
        backendUrlField.value = initialBackend;
    }
    connectWebSocket();
    fetchConfig();
</script>
</body>
</html>
